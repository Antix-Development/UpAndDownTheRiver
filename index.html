<!DOCTYPE html>
<html lang="en">
  
  <head>
    <meta charset="utf-8">
    <title>Up and Down the River</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
      
      :root {
        --button-background: #eee;
        --button-border: 2px solid #aaa;
        --button-color: #444;

        --button-hover-background: #06f;
        --button-hover-border: 2px solid #38f;
        --button-hover-color: #eee;
        
        --button-active-background: #39f;
        --button-active-border: 2px solid #5bf;
        --button-active-color: #fff;

        --button-disabled-background: #666;
        --button-disabled-border: 2px solid #222;
        --button-disabled-color: #111;

        --normal-element-height: 56px;
      }

      * {
        box-sizing: border-box;
        user-select: none;
        font-family: 'Century Gothic', 'Arial', 'Courier New', Courier, monospace;
        font-weight: bold;
        color: #eee;
        outline: 0;
      }

      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-repeat: repeat; /* background image will be set in code later */
      }

      input {
        margin: 0 0 3px 0;
        height: var(--normal-element-height);
        font-size: 30px;
        color: #fff;
        background-color: #fff4;
        border: 1px solid #fff8;
        border-radius: 6px;
        padding: 0 20px;
        text-align: center;
        text-transform: capitalize;
      }

      label {
        display: block;
        margin: 0;
        height: var(--normal-element-height);
        font-size: 30px;
      }

      button {
        margin: 0;
        height: var(--normal-element-height);
        text-align: center;
        padding: 0 10px 0 10px;
        border-radius: 5px;
        cursor: pointer;
        background-color: var(--button-background);
        border: var(--button-border);
        color: var(--button-color);
      }

      button:hover {
        background-color: var(--button-hover-background);
        border: var(--button-hover-border);
        color: var(--button-hover-color);
      }

      button:active {
        background-color: var(--button-active-background);
        border: var(--button-active-border);
        color: var(--button-active-color);
      }

      button:disabled {
        background-color: var(--button-disabled-background);
        border: var(--button-disabled-border);
        color: var(--button-disabled-color);
      }

      button:disabled:hover {
        cursor:not-allowed;
      }

      h2 {
        margin: 0;
        font-size: 30px;
        padding: 20px 0 20px 0;
      }

      h3 {
        margin: 0;
        font-size: 24px;
        padding: 0;
      }

      p {
        font-size: 24px;
        font-weight: normal;
        line-height: 30px;
        padding: 0 80px;
        margin: 0;
        text-align: justify;
      }

      ::-webkit-scrollbar {
        width: 10px;
        background: #282;
      }

      ::-webkit-scrollbar-thumb {
        background: #5b5;
      }

      ::-webkit-scrollbar-corner {
        background: #282;
      }

      #view_panel {
        height: 100vh;
        display: grid;
        grid-template-columns: 1fr;
        grid-template-rows: 64px 1fr 0px;
        grid-column-gap: 0px;
        grid-row-gap: 0px;
      }

      #header_panel {
        grid-area: 1 / 1 / 2 / 2;
      }

      #content_panel {
        grid-area: 2 / 1 / 3 / 2;
        overflow-y: scroll;
        scrollbar-color: #5b5 #282;
        scrollbar-width: thin;
      }

      #footer_panel {
        grid-area: 3 / 1 / 4 / 2;
      }

      .player_header {
        display: inline-block;
        height: 100%;
        margin: 3px;
        padding: 3px;
        vertical-align: top;
      }

      .header_label {
        display: inline-block;
        padding: 0 16px;
        text-transform: capitalize;
      }

      .sidebar {
        width: 4.9%;
      }

      .big_btn {
        height: 56px;
        padding: 0 30px 0 30px;
        font-size: 26px;
        border: var(--button-border);
      }

      .hud_btn {
        height: var(--normal-element-height);
        padding: 0, 10px, 0, 10px;
        font-size: 24px;
        margin-left: 3px;
        float: right;
      }

      .player_name {
        font-weight: bold;
        text-align: center;
      }

      .hud_label {
        display: inline-block;
      }

      .player_column {
        box-sizing: border-box;
        background-color: #0003;
        display: inline-block;
        border: 3px solid #aaa;
        border-radius: 5px;
        height: 100%;
        margin: 3px;
        padding: 4px 4px 1px 4px;

        vertical-align: top;
      }

      .bright {
        background-color: #fff2;
      }

      .error {
        color: #e00;
        text-shadow: 0px 0px 6px #fcd;
      }

      .yes_button_selected {
        background-color: #af0;
        border-color: #ffc;
      }

      .no_button_selected {
        background-color: #f43;
        border-color: #f87;
      }

      .right {
        float: right;
      }
      
      .left {
        float: left;
      }

      .center {
        text-align: center;
      }

      .full_width {
        width: 100%
      }

      .hidden {
        display: none;
      }

      .misdeal_button {
        margin-left: 20px;
      }

      .history_date {
        width: 12%;
      }

      .history_duration {
        width: 8%;
      }

      .history_rounds {
        width: 8%;
      }

      .history_players {
        width: 60%;
      }

      .history_hr {
        margin-bottom: 16px;
      }

    </style>
  
  </head>
  
  <body>
    <!-- Truchet tile -->
    <img id="tile" class="hidden" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABmJLR0QA/wCIAIg/Yj3ZAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH5wcaARwomBF14QAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAABfUlEQVR42u3dQQHAQBCEsGn9e94TQtCQP7u7m7L92wZBHAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEAAAAQAQAAABABAAEAdAQBxBADEEQAQRwBAHAEAcQQAxBEAEEcAQBwBAHEEAMQRABBHAEAcAQBxBADEEQAQRwBAHAEAcQQAxBEAEEcAQBwBAHEEAMQRABBHAEAcAQBxBADEEQAQRwBAHAEAcQQAxBEAEEcAQBwBAHEEAMQRABBHAEAcAQBxBADEEQAQRwBAHMFX36fXe6dZ/w3fdap0AAAAAElFTkSuQmCC">

    <div id="view_panel">

      <!-- Sticky header to ALWAYS show important game information like player names, etc -->
      <div id="header_panel" class="panel"></div>

    <!-- The main game display container -->
    <div id="content_panel">

      <div id="title_panel" class=" center">
        <h1>Up & Down The River</h1>
      </div>

      <!-- Main menu panel -->
      <div id="new_game_panel" class="center">
        <button class="big_btn" onclick="startNewGame();">Start New Game</button>
        <button class="big_btn" onclick="showRules(true);">How To Play</button>
        <!-- <button class="big_btn" onclick="showSettings(true);">Settings</button><br><br> -->
        <button class="big_btn" onclick="showAbout(true);">About</button>
        <button class="big_btn" onclick="showHistory(true);">History</button>
        <br><br>
      </div>

      <!-- Game rules panel -->
      <div id="rules_panel" class="hidden">
        <br>
        <p>
          Up and Down the River is a social card game best enjoyed after dinner with good friends, easy listening music, and a few beverages of your choice.<br><br>

          The game is played in rounds, with each round consisting of a number of tricks. The game style is similar to the well known card game <a href="https://en.wikipedia.org/wiki/Euchre" target="_blank">Euchre</a>.<br><br>
          
          When playing "up the river" the number of cards dealt to each player increases from one card in the first round, to the number of cards chosen as the length of the river in the last round.<br><br>
          
          Then the game is played back "down the river" starting with the maximum number of cards, to one card in the last round.<br><br>
          
          You should be able to see where the name "Up and Down the River" comes from now.<br><br>

          Please note that this game is one of many variants of the "Up and Down the River" card game. If it wasn't what you were expecting, or you don't like it, well maybe you should just "Go Fish" instead ¯\_(ツ)_/¯<br><br>
        </p>
        <h2 class="center">How to Play</h2><br>
        <p>
          To determine the dealer the deck is shuffled and cards are dealt one at a time face up to all players in order until a Jack is dealt. The player to whom the jack was dealt is the dealer.<br><br>

          Once the dealer is determined, enter into the application the number of players and length of the river. Then enter the names of the players starting with the dealer and proceeding clockwise after that.<br><br>
          
          The dealer gathers and shuffles the deck, and then deals the required number of cards for the round to each player.<br><br>
          
          The dealer then turns the next card in the deck face up, and this card denotes the trump suit.<br><br>
          
          When played, a trump card "trumps" (or beats) any other card of any other suit, no matter what that cards face value is. For example, if Hearts are trumps then the Jack of Hearts (known as the left bower) is the highest card in the game, followed by the Jack of Diamonds (known as the right bower), then the Ace of Hearts,King of Hearts, and so on.<br><br>
          
          As in Euchre, players must follow suit if they have that suit.<br><br>
          
          With the trump suit established, each player examines their cards and determines how many tricks they think they can claim in the current round. This number is entered into the application.<br><br>
          
          The last player to claim tricks is the dealer where an important caveat applies<br><br>

          The number of tricks called cannot be equal to the number of tricks in the round, therefore the dealer must call in a way to make this so.<br><br>
              
          &emsp;- Example, if in round 7, 6 tricks are called the dealer cannot call 1 trick.<br>
          &emsp;- Example, if in round 7, 7 tricks are called the dealer cannot pass and must call at least 1 trick.<br><br>
          
          Once all players have informed the keeper how many tricks they hope to claim, the round begins with the lead player (the person to the left of the dealer) laying down a card from their hand.<br><br>

          NOTE: During play, The dealer is highlighted with a blue border, and the lead player is highlighted with a green border.<br><br>

          As mentioned previously player must follow suit.<br><br>
          
          If a player cannot follow suit then they are free to play any card in their hand.<br><br>
          
          Once all players have laid down a card, the winner of the round is determined and they claim the trick.<br><br>
          
          The winner of the trick now becomes the lead player and the round continues as described above, until all tricks have been claimed.<br><br>
          
          Once a round is complete, players are awarded points according to how many tricks they claimed versus how many tricks they actually took.<br><br>
          
          If a player takes the number of tricks that they claimed then they are awarded 10 points and an additional 1 point for each trick they took.<br><br>
          
          If a player claims 0 tricks and they take 0 zero tricks then they are awarded 5 points<br><br>
          
          If a player does not take the number of tricks they claimed then they are not awarded any points.<br><br>
          
          Once all rounds have been played the winner is the player with the most accumulated points.<br><br>
        </p>
        <div class="center">
          <button class="big_btn" onclick="showRules(false);">Okay</button><br><br>
        </div>
      </div>

      <!-- Game credits panel -->
      <div id="about_panel" class="center hidden">
        <br>
        <h2>Up and Down the River version 2.0</h2>
        <h2>(c) 2023 Cliff Earl, <a href="https://github.com/Antix-Development" target="_blank">Antix Development</a>.</h2>
        <h2>Created using MicroSoft <a href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a></h2><br>
        <br>
        <div class="center">
          <button class="big_btn" onclick="window.open('https://www.buymeacoffee.com/antixdevelu', '_blank');">Buy Cliff a Coffee</button><br><br>
          <button class="big_btn" onclick="showAbout(false);">Okay</button>
        </div>
      </div>

      <!-- Settings panel -->
      <div id="settings_panel" class="center hidden">

        <!-- TODO: Add settings controls -->

        <div class="center">
          <button class="big_btn" onclick="showSettings(false);">Okay</button>
        </div>
      </div>
      
      <!-- History panel -->
      <div id="history_panel" class="center hidden">
        <!-- <h1>Hall of Fame (and shame)</h1> -->
        <div id="history_entries">
          <div>
            <label class="hud_label history_date">Date</label>
            <label class="hud_label history_duration">Duration</label>
            <label class="hud_label history_rounds">Rounds</label>
            <label class="hud_label history_players">Players & Scores</label>
          </div>
          <hr class="history_hr">

          <!-- This content will be generated -->
        </div>
        <div class="center">
          <br>
          <button class="big_btn" onclick="showHistory(false);">Okay</button>
        </div>
      </div>


      <!-- Player count panel -->
      <div id="player_count_panel" class="center hidden margin-top">
        <h2 id="player_count_label"></h2>
        <button class="big_btn" onclick="setPlayerCount(2);">2</button>
        <button class="big_btn" onclick="setPlayerCount(3);">3</button>
        <button class="big_btn" onclick="setPlayerCount(4);">4</button>
        <button class="big_btn" onclick="setPlayerCount(5);">5</button>
        <button class="big_btn" onclick="setPlayerCount(6);">6</button>
      </div>

      <!-- River length panel -->
      <div id="river_length_panel" class="center hidden margin-top">
        <h2>And how long will the river be?</h2>
        <button id="river_length_button_1" class="big_btn" onclick="setRiverLength(1);">1</button>
        <button id="river_length_button_2" class="big_btn" onclick="setRiverLength(2);">2</button>
        <button id="river_length_button_3" class="big_btn" onclick="setRiverLength(3);">3</button>
        <button id="river_length_button_4" class="big_btn" onclick="setRiverLength(4);">4</button>
        <button id="river_length_button_5" class="big_btn" onclick="setRiverLength(5);">5</button>
        <button id="river_length_button_6" class="big_btn" onclick="setRiverLength(6);">6</button>
        <button id="river_length_button_7" class="big_btn" onclick="setRiverLength(7);">7</button>
        <button id="river_length_button_8" class="big_btn" onclick="setRiverLength(8);">8</button>
        <button id="river_length_button_9" class="big_btn" onclick="setRiverLength(9);">9</button>
        <button id="river_length_button_10" class="big_btn" onclick="setRiverLength(10);">10</button>
      </div>

      <!-- Player panels -->
      <div id="player_panels" class="panel">
      </div>

      <div id="entering_player_names_panel" class="center hidden margin-top">
        <h2>Enter player names</h2>
        <button class="big_btn" onclick="playerNamesEntered();">Continue</button>
      </div>

      <h2 id="end_round_error_label" class="error center hidden">Available tricks exceeded, review claims.</h2>

    </div>

    <div id="footer_panel" class="center margin-top">
      
      <div id="player_bidding_panel" class="center hidden margin-top">
        <h2 id="bid_label"></h2>
        <button id="trick_button_0" class="big_btn" onclick="claimTricks(0);">0</button>
        <button id="trick_button_1" class="big_btn" onclick="claimTricks(1);">1</button>
        <button id="trick_button_2" class="big_btn" onclick="claimTricks(2);">2</button>
        <button id="trick_button_3" class="big_btn" onclick="claimTricks(3);">3</button>
        <button id="trick_button_4" class="big_btn" onclick="claimTricks(4);">4</button>
        <button id="trick_button_5" class="big_btn" onclick="claimTricks(5);">5</button>
        <button id="trick_button_6" class="big_btn" onclick="claimTricks(6);">6</button>
        <button id="trick_button_7" class="big_btn" onclick="claimTricks(7);">7</button>
        <button id="trick_button_8" class="big_btn" onclick="claimTricks(8);">8</button>
        <button id="trick_button_9" class="big_btn" onclick="claimTricks(9);">9</button>
        <button id="trick_button_10" class="big_btn" onclick="claimTricks(10);">10</button>
        <button class="big_btn left misdeal_button" onclick="misdeal();">Misdeal</button>
      </div>

      <div id="end_round_panel" class="center hidden margin-top">
        <h2>Did the players claim their tricks or not.</h2>
        <button id="end_round_button" class="big_btn" onclick="confirmEndRound();">Continue</button>
        <button class="big_btn left misdeal_button" onclick="misdeal();">Misdeal</button>
      </div>

      <div id="end_game_panel" class="center hidden margin-top">
        <h1 id="winner_label"></h1>
        <button class="big_btn" onclick="location.reload();">Play Again</button><br><br>
      </div>

    </div>

    </div>

  </body>

  <script>
    var 
    roundHeaderLabel,

    round,
    rounds = [],
    riverLength,

    playerCount,
    players = [],

    dealer, // indexes into players array
    leader,
    bidder,

    tricksClaimedByOtherPlayers,

    roundDisplayPanel, // Appears on left side of display and shows which round is being played

    historicEvents,
    startDate,

    cachedRounds,
    cachedDealer,

    misdealHappened;

    // Utility
    const 
    log = (t) => console.log(t),
    getByID = (id) => document.getElementById(id),
    showElement = (el, state) => el.style.display = (state) ? 'block' : 'none',
    createElement = (type) => document.createElement(type),
    newLabel = (text) => { var label = createElement('label'); label.innerHTML = text; return label; },

    viewPanel = getByID('view_panel'),
    headerPanel = getByID('header_panel'),
    contentPanel = getByID('content_panel'),
    footerPanel = getByID('footer_panel'),

    titlePanel = getByID('title_panel'),
    settingsPanel = getByID('settings_panel'),
    historyPanel = getByID('history_panel'),
    historyEntries = getByID('history_entries'),
    newGamePanel = getByID('new_game_panel'),
    endGamePanel = getByID('end_game_panel'),
    playerCountPanel = getByID('player_count_panel'),
    playerCountLabel = getByID('player_count_label'),
    riverLengthPanel = getByID('river_length_panel'),
    biddingPanel = getByID('player_bidding_panel'),
    endRoundPanel = getByID('end_round_panel'),
    endRoundButton = getByID('end_round_button'),
    endRoundErrorLabel = getByID('end_round_error_label'),
    rulesPanel = getByID('rules_panel'),
    aboutPanel = getByID('about_panel'),
    enteringPlayerNamesPanel = getByID('entering_player_names_panel'),
    playerPanels = getByID('player_panels'),
    bidLabel = getByID('bid_label'),
    winnerLabel = getByID('winner_label'),

    WINNER_BORDER_COLOR = '#fc0',
    DEALER_BORDER_COLOR = '#08f',
    LEADER_BORDER_COLOR = '#4f4',
    DEFAULT_BORDER_COLOR = '#aaa',

    maxRiverLengthByPlayerCount = [0, 10, 10, 10, 10, 10, 8, 7, 6], // Basically 52 cards / number = maximum length of river

    SETTINGS_FILENAME = 'com.antix.up_and_down_the_river',
    HISTORY_FILENAME = 'com.antix.up_and_down_the_river_history',

    // User clicked the "New Game" button
    startNewGame = () => {
      showElement(newGamePanel, false); // Hide current panel (title panel)

      const hours = new Date().getHours(); // Generate the "how many players" string according to the time of day
      var str = 'morning';

      if (hours >= 17) {
        str = 'evening';

      } else if (hours >= 12) {
        str = 'afternoon';
      }
      playerCountLabel.innerHTML = `How many people will be playing this ${str}?`;

      showElement(titlePanel, false);
      showElement(playerCountPanel, true); // Show next panel (set player count panel)
    },

    // User set number of players
    setPlayerCount = (count) => {
      showElement(playerCountPanel, false); // Hide current panel (set player count panel)

      playerCount = count;

      for (let i = 0; i < 10; i++)
        getByID(`river_length_button_${i + 1}`).disabled = false; // Enable all buttons

      for (let i = maxRiverLengthByPlayerCount[count]; i < 10; i++)
        getByID(`river_length_button_${i + 1}`).disabled = true; // Disable invalid buttons

      showElement(riverLengthPanel, true); // Show next panel (set river length panel)
    },

    // User set river length (number of rounds up and down to be played)
    setRiverLength = (length) => {
      showElement(riverLengthPanel, false); // Hide current panel (set river length panel)

      riverLength = length;

      for (let i = 1; i <= length; i++) rounds.push(i); // Rounds contains number of cards to be dealt each round
      for (let i = length; i > 0; i--) rounds.push(i);

      for (let i = 0; i < 10; i++) getByID(`trick_button_${i + 1}`).disabled = false; // Enable all buttons
      
      for (let i = length; i < 10; i++) getByID(`trick_button_${i + 1}`).disabled = true; // Disable invalid buttons

      roundHeaderPanel = createElement('div'); // Create panel where round numbers will be displayed
      roundHeaderPanel.id = 'roundHeaderPanel';
      roundHeaderPanel.classList.add('center', 'player_header', 'sidebar');
      headerPanel.appendChild(roundHeaderPanel);

      roundHeaderLabel = createElement('label');
      roundHeaderLabel.innerHTML = '&nbsp;';
      roundHeaderLabel.classList.add('center', 'header_label');
      roundHeaderPanel.appendChild(roundHeaderLabel);

      roundDisplayPanel = createElement('div'); // Create panel where round numbers will be displayed
      roundDisplayPanel.id = 'roundDisplayPanel';
      roundDisplayPanel.classList.add('center', 'player_column', 'sidebar');
      roundDisplayPanel.appendChild(newLabel(''));
      playerPanels.appendChild(roundDisplayPanel);

      // 
      // Generate players
      // 

      const columnWidth = `${(95 / playerCount) - 1}%`;

      for (let i = 0; i < playerCount; i++) {

        var playerHeaderPanel = createElement('div'); // Players header panel
        playerHeaderPanel.classList.add('center', 'player_header');
        playerHeaderPanel.style.width = columnWidth;

        var nameHeaderLabel = createElement('label');
        nameHeaderLabel.classList.add('center', 'header_label');
        playerHeaderPanel.appendChild(nameHeaderLabel);

        var scoreHeaderLabel = createElement('label');
        scoreHeaderLabel.classList.add('right', 'header_label');
        playerHeaderPanel.appendChild(scoreHeaderLabel);

        headerPanel.appendChild(playerHeaderPanel); // Append to header panel containing all player header panels

        var playerPanel = createElement('div'); // All other player related elements will be appended in this panel
        playerPanel.classList.add('center', 'player_column');
        playerPanel.style.width = columnWidth;

        // Set panel frame colors according to role
        playerPanel.style.borderColor = DEFAULT_BORDER_COLOR; // i != 0 or 1
        if (i === 0) playerPanel.style.borderColor = DEALER_BORDER_COLOR;
        if (i === 1) playerPanel.style.borderColor = LEADER_BORDER_COLOR;

        var input = createElement('input'); // Create player name text input
        input.setAttribute('type', 'text');
        input.classList.add('full_width', 'player_name');
        input.placeholder  = `player${i + 1}`;
        playerPanel.appendChild(input);

        var gamePanel = createElement('div');
        playerPanel.appendChild(gamePanel);

        players.push({ // Create the player
          id: i,
          hasBid: false,
          scoreUpdated: false,
          name: '',
          score: 0,
          points: 0, // Points scored for current round
          claimedTricks: 0,
          claimedTricksLabel: null,
          gotTricks: false,
          pointsLabel: null,
          yesButton: null,
          noButton: null,
          playerPanel: playerPanel,
          gamePanel: gamePanel,
          roundPanel: null,
          input: input, // Where player name is set
          nameHeaderLabel: nameHeaderLabel,
          scoreHeaderLabel: scoreHeaderLabel,
        });

        playerPanels.appendChild(playerPanel); // Append current players panel to all player panels
      }
      showElement(enteringPlayerNamesPanel, true); // Show next panel (set player names panel)
    },

    // User has confirmed that all player names have been entered
    playerNamesEntered = () => {

      for (let i = 0; i < players.length; i++) {
        const player = players[i];
        if (player.input.value === "") return; // Don't proceed until all names have a value

        player.name = `${player.input.value.charAt(0).toUpperCase()}${player.input.value.slice(1)}`; // Capitalize name because CSS text-transrofm does not propogate :(

        player.nameHeaderLabel.innerHTML = player.input.value; // Set player name in header
        player.scoreHeaderLabel.innerHTML = player.score;

        player.input.classList.add('hidden');
      }

      roundDisplayPanel.innerHTML = '';

      showElement(enteringPlayerNamesPanel, false); // Hide current panel (set player names panel)

      for (let i = 0; i < players.length; i++)
      players[i].input.readOnly = true;
    
      dealer = -1; // Dealer is first player

      startDate = new Date();

      advance();
    },

    // deepCopy = (source) => JSON.parse(JSON.stringify(source)),

    // Advance to the next round
    advance = () => {

      // Cache data for use if there was a misdeal
      cachedRounds = [...rounds];//deepCopy(rounds);
      cachedDealer = dealer;//deepCopy(dealer);

      showElement(endRoundPanel, false); // Hide current panel (end round panel)

      if (rounds.length === 0) return gameOver();

      round = rounds.shift(); // Number of cards to deal

      roundHeaderLabel.innerHTML = round;

      for (let i = 0; i < 10; i++) getByID(`trick_button_${i + 1}`).disabled = false; // Enable all buttons

      endRoundErrorLabel.classList.add('hidden');

      tricksClaimedByOtherPlayers = 0;

      dealer ++; // Increment dealer and wrap in array
      if (dealer == players.length) dealer = 0;

      leader = dealer + 1; // Increment leader and wrap in array
      if (leader == players.length) leader = 0;

      bidder = leader; // First bidder is always the leader

      updateBiddingLabelText();

      players.forEach(player => {
        player.score += player.points; // Add points from last round

        player.oldScore = player.score; // Cache for reset when misdeal

        player.scoreHeaderLabel.innerHTML = player.score;

        player.hasBid = false;
        player.scoreUpdated = false;
        player.points = 0;
        player.gotTricks = false;

        var roundPanel = createElement('div');

        player.roundPanel = roundPanel; // Used for removing in the case of a misdeal

        var label = newLabel(player.score);
        label.classList.add('hud_label', 'left');
        roundPanel.appendChild(label);

        player.gamePanel.appendChild(roundPanel);

        player.playerPanel.style.borderColor = DEFAULT_BORDER_COLOR;
        if (player.id === dealer) player.playerPanel.style.borderColor = DEALER_BORDER_COLOR;
        if (player.id === leader) player.playerPanel.style.borderColor = LEADER_BORDER_COLOR;

      });

      for (let i = round; i < 10; i++)
        getByID(`trick_button_${i + 1}`).disabled = true; // Disable invalid buttons

      viewPanel.style.gridTemplateRows = '64px 1fr 165px';
        
      roundDisplayPanel.appendChild(newLabel(round));

      contentPanel.scrollTop = contentPanel.scrollHeight; // Force new content to be visible

      showElement(biddingPanel, true); // Show next panel (end round panel)
    },

    // Game is over, determine and display winner/s
    gameOver = () => {
    
      roundHeaderLabel.innerHTML = '-';

      players.sort((a, b) => { return b.score - a.score; }); // Sort high to low scores

      let event = newHistoricEvent();
      historicEvents.push(event);
      displayHistoricEvent(event);

      // Remove player panel effects
      for (let i = 0; i < players.length; i++) {
        players[i].playerPanel.style.borderColor = DEFAULT_BORDER_COLOR;
        players[i].playerPanel.classList.remove('bright');
      }

      var winners = [];
      for (let i = 0; i < players.length; i++) {
        if (players[i].score === players[0].score) {
          winners.push(players[i]); // Create an array of all players with the best score
          players[i].playerPanel.style.borderColor = WINNER_BORDER_COLOR;
        }
      }

      if (winners.length === 1) {
        winnerLabel.innerHTML = `${winners[0].name} is the winner.`; // There was a single winner

      } else { // The game was drawn between two or more players

        var str = 'The game is drawn between ';
        for (let i = 0; i < winners.length - 1; i++) {
          str += `${winners[i].name},`;
        }

        winnerLabel.innerHTML = str + ` and ${winners[winners.length - 1].name}.`; // Append last winner
      }

      showElement(endGamePanel, true); // Show next panel
    },

    // Update the string for querying any players claim on tricks
    updateBiddingLabelText = () => {

      const biddingPlayer = players[bidder];

      getByID('trick_button_0').disabled = false;

      bidLabel.innerHTML = `Round ${round}: How many tricks does ${biddingPlayer.name} claim?`;
      biddingPlayer.playerPanel.classList.add('bright');

      if (biddingPlayer.id == dealer) {

        if (tricksClaimedByOtherPlayers === round) {
          getByID('trick_button_0').disabled = true; // Cannot claim zero tricks
        
        } else if (tricksClaimedByOtherPlayers > 0 && tricksClaimedByOtherPlayers < round) {
          getByID(`trick_button_${round - tricksClaimedByOtherPlayers}`).disabled = true; // Cannot claim tricks that cause maximum tricks to be claimed
        
        } else if (round === 1 && tricksClaimedByOtherPlayers === 0) {
          getByID('trick_button_0').disabled = true; // Cannot claim one trick

        }

        // if (round != 1 && tricksClaimedByOtherPlayers === 0) {
        //   getByID('trick_button_0').disabled = true; // Cannot claim zero tricks
        // }
      }
    },

    // Determine if all players have claimed a number of tricks
    allPlayersHaveBid = () => {
      for (let i = 0; i < players.length; i++)
        if (!players[i].hasBid) return false; // Not all players have bid yet

      return true; // All players have bid
    },

    // Determine if all players achieved or did not achieve their claims on tricks
    updatedAllScores = () => {
      for (let i = 0; i < players.length; i++)
        if (!players[i].scoreUpdated) return false;
      
        return true;
    },

    // Cleanup after the current round has ended
    nextRound = () => {
      for (let i = 0; i < players.length; i++) {
        const player = players[i];
        player.roundPanel.removeChild(player.yesButton);
        player.roundPanel.removeChild(player.noButton);
        
        if (player.roundPanel) player.roundPanel.style.backgroundColor = '#0000';
      }
      advance();
    },

    // Enable or disable the given players yes/no buttons according to the given state
    enableYesNoButtons = (player, state) => {
      player.yesButton.disabled = !state;
      player.noButton.disabled = !state;
    },

    //Set the number of claimed tricks for the bidding player to the given number
    claimTricks = (number) => {
      tricksClaimedByOtherPlayers += number;

      var biddingPlayer = players[bidder];

      biddingPlayer.claimedTricks = number;
      biddingPlayer.hasBid = true;

      // 
      // Generate UI elements
      // 

      const roundPanel = biddingPlayer.roundPanel;
      
      var label = newLabel(biddingPlayer.claimedTricks);
      label.classList.add('hud_label');
      biddingPlayer.claimedTricksLabel = label;

      var yesButton = createElement('button');
      yesButton.classList.add('hud_btn', 'hidden');
      yesButton.innerHTML = 'Yes';
      biddingPlayer.yesButton = yesButton;


      // Yes button click handler
      yesButton.onclick = () => {
        biddingPlayer.scoreUpdated = true;

        if (biddingPlayer.claimedTricks === 0) {
          biddingPlayer.points = 5; // Player went for and got got 0 tricks
          label.innerHTML = '+5';

        } else {
          biddingPlayer.points = 10 + biddingPlayer.claimedTricks; // Player went for and got specified number of tricks
          label.innerHTML = `+${10 + biddingPlayer.claimedTricks}`;
        }

        biddingPlayer.gotTricks = true;
        noButton.classList.remove('no_button_selected');
        yesButton.classList.add('yes_button_selected');
        sanityCheck();
      };

      var noButton = createElement('button');
      noButton.classList.add('hud_btn', 'hidden');
      noButton.innerHTML = 'No';
      biddingPlayer.noButton = noButton;

      noButton.onclick = () => { // No button click handler
        biddingPlayer.scoreUpdated = true;
        biddingPlayer.points = 0;
        label.innerHTML = '-';

        biddingPlayer.gotTricks = false;
        yesButton.classList.remove('yes_button_selected');
        noButton.classList.add('no_button_selected');
        sanityCheck();
      };

      enableYesNoButtons(biddingPlayer, false);

      roundPanel.appendChild(label);
      roundPanel.appendChild(noButton);
      roundPanel.appendChild(yesButton);

      bidder ++;
      if (bidder === players.length) bidder = 0;

      for (let i = 0; i < players.length; i++) players[i].playerPanel.classList.remove('bright');

      updateBiddingLabelText();

      if (allPlayersHaveBid()) {

        // 
        // All players have claimed tricks
        // 

        for (let i = 0; i < players.length; i++) {
          players[i].yesButton.classList.remove('hidden');
          players[i].noButton.classList.remove('hidden');

          players[i].playerPanel.classList.remove('bright');
        }

        showElement(biddingPanel, false);

        endRoundButton.disabled = true;

        showElement(endRoundPanel, true);

        for (let i = 0; i < players.length; i++) enableYesNoButtons(players[i], true); // Enable yes/no buttons for all players
      }
    },

    // Display an error message if the total number of claimed tricks exceeds the number of tricks available
    sanityCheck = () => {
      var 
      claimed = 0,
      enableButton = true;

      for (let i = 0; i < players.length; i++)
        if (players[i].gotTricks) claimed += players[i].claimedTricks;

      if (claimed > round) { // Exceeded, show the error message
        endRoundErrorLabel.classList.remove('hidden');
        enableButton = false;
        endRoundButton.disabled = true;

      } else { // Hide the error message
        endRoundErrorLabel.classList.add('hidden');

      }

      // NOTE: This doesn't really work how I intended, maybe it should be removed?
      if (updatedAllScores() && enableButton) {
        endRoundButton.disabled = false;
      }
    },

    // User confirmed the round has ended
    confirmEndRound = () => {
      if (updatedAllScores()) nextRound();
    },

    // User clicked the "How To Play" button
    showRules = (state) => {
      showElement(rulesPanel, state);
      showElement(newGamePanel, !state);
    },

    // User clicked the "About" button
    showAbout = (state) => {
      showElement(aboutPanel, state);
      showElement(newGamePanel, !state);
    },

    // User clicked the "Settings" button
    showSettings = (state) => {
      showElement(settingsPanel, state);
      showElement(newGamePanel, !state);
    },

    // User clicked the "History" button
    showHistory = (state) => {
      showElement(historyPanel, state);
      showElement(newGamePanel, !state);
      showElement(titlePanel, !state);
    },

    // Reset current round when a misdeal occurred
    misdeal = () => {
      // Reset players
      for (let i = 0; i < players.length; i++) {
        const player = players[i];
        player.roundPanel.parentNode.removeChild(player.roundPanel); // Remove all HTML elements that were added to the players panel when the round began

        player.score = player.oldScore; // reset
        player.points = 0;
      }

      // Reset game data
      dealer = cachedDealer;
      rounds = cachedRounds;
      roundDisplayPanel.lastChild.parentNode.removeChild(roundDisplayPanel.lastChild);

      // Hide elements that might have been visible
      showElement(endRoundErrorLabel, false);
      showElement(endRoundPanel, false);
      showElement(biddingPanel, false);

      advance(); // Restart round
    };

    
    // Load settings
    let settings = localStorage.getItem(SETTINGS_FILENAME);

    if (!settings) {
      // Settings don't exist, create and save default settings
      settings = {
        // TODO: Create settings
      };
      // localStorage.setItem(SETTINGS_FILENAME, settings)
    }

    // Apply settings

    // 
    // TODO: Apply settings
    // 

    const root = document.documentElement;
    // log(`The value of --background-color is: ${getComputedStyle(root).getPropertyValue('--background-color')}`);
    // root.style.setProperty('--background-color', '#f0f');

    // 
    // Draw a background using truchet tiles
    // 

    // 
    // Process historic events (history of previous games)
    // 

    const 
    newHistoricEvent = () => {
      let playerText = '';
      for (let i = 0; i < players.length; i++) {
        const player = players[i];
        playerText += `${player.name}(${player.score}), `;
      }

      return {
        date: startDate.toLocaleString(),
        duration: `${Math.floor(Math.abs(new Date() - startDate) / (1000 * 60))} mins`,
        players: playerText.slice(0, -2),
        rounds: riverLength
      }
    },

    displayHistoricEvent = (event) => {
      let container = createElement('div');

      let dateLabel = createElement('label');
      dateLabel.classList.add('hud_label', 'history_date');
      dateLabel.innerHTML = event.date;
      container.appendChild(dateLabel);

      let durationLabel = createElement('label');
      durationLabel.classList.add('hud_label', 'history_duration');
      durationLabel.innerHTML = event.duration;
      container.appendChild(durationLabel);

      let roundsLabel = createElement('label');
      roundsLabel.classList.add('hud_label', 'history_rounds');
      roundsLabel.innerHTML = event.rounds;
      container.appendChild(roundsLabel);

      let playersLabel = createElement('label');
      playersLabel.classList.add('hud_label', 'history_players');
      playersLabel.innerHTML = event.players;
      container.appendChild(playersLabel);

      historyEntries.appendChild(container);
    };

    // localStorage.removeItem(HISTORY_FILENAME);

    historicEvents = localStorage.getItem(HISTORY_FILENAME);

    if (historicEvents) {
      historicEvents = JSON.parse(historicEvents);

    } else {
      historicEvents = [];
      localStorage.setItem(HISTORY_FILENAME, JSON.stringify(historicEvents));
    }

    for (let i = 0; i < historicEvents.length; i++) {
      displayHistoricEvent(historicEvents[i]);
    }

    // 
    // Generate background using "Truchet Tiles"
    // 

    const 
    TILE_SIZE = 128,
    NUM_TILES = 16, 
    PI = Math.PI,

    tileImage = getByID('tile'), // Truchet tile

    // Init drawing surface
    canvas = createElement('canvas'),
    context = canvas.getContext('2d');
    canvas.width = TILE_SIZE * NUM_TILES;
    canvas.height = TILE_SIZE * NUM_TILES;

    // Clear canvas
    context.fillStyle = ('#393');
    context.fillRect(0, 0, 2048, 2048);

    context.globalAlpha  = 0.1; // Set alpha so tiles appear to be a little brighter than the background color

    for (let r = 0; r < NUM_TILES; r++) {
      for (let c = 0; c < NUM_TILES; c++) {
        let rotation = [0, PI * .5, PI, PI * 1.5][Math.floor(Math.random() * 4)]; // Random rotation
        context.save();
        context.translate((c * TILE_SIZE) + (TILE_SIZE / 2), (r * TILE_SIZE) + (TILE_SIZE / 2));
        context.rotate(rotation);
        context.drawImage(tileImage, -TILE_SIZE / 2, -TILE_SIZE / 2, TILE_SIZE, TILE_SIZE);
        context.restore();
      }
    }
    document.body.style.backgroundImage = `url("${canvas.toDataURL()}")`; // Set background image

</script>

</html>
